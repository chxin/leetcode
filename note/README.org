* conclusion
** [[../213.house-robber-ii.cpp]]
*** 我的思路，没解出来
先不考虑最后一个房间，这就是直线抢劫问题。
那么，就算出排除了最后一个房间的dp数组。
最后考虑最后一个房间：如果第一个房间抢了，得到dp[n-1], dp[n-2]，那么dp[n] = max(dp[n-1], dp[n-2]);
如果第一个房间不抢，那么dp[n] = max(dp[n-1], nums[n]+dp[n-2])。

所以问题关键在于：如何判断第一个房间是否抢了？
*** 分析
1. 当下判断是很复杂的时候，但只有两种或较少种可能的时候，就直接分情况讨论
2. 在我的思路中，能否敏感察觉到，dp[n]的解法就是在线性抢劫问题递归的一部分呢。
这样，就会简化问题的思考量，从而发现，两次nums的范围（一次掐头，一次去尾）进行迭代就行了？
